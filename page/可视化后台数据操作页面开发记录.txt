2016/11/4
设计模式
动态创建？ajxa加载？
动态创建
document.createElement 兼容性 
主要是在IE下面创建的元素不可以设置name属性；
var btnEl; 
  
try { 
    btnEl = document.createElement('<BUTTON name=damon type=reset></BUTTON>'); 
} catch(e){} 
  
if(! btnEl) { 
    btnEl = document.createElement('button'); 
  
    var aType = document.createAttribute('type'); 
    var aName = document.createAttribute('name'); 
  
    aType.value = 'reset'; 
    aName.value = 'damon'; 
  
    btnEl.setAttributeNode(aType); 
    btnEl.setAttributeNode(aName); 
} 
  
document.body.appendChild(btnEl); 
alert(document.getElementsByTagName('button')[0].type +','+ 
    document.getElementsByTagName('button')[0].name);
阻止双击元素变蓝事件
$("*").bind("selectstart", function () { return false; })
jquery中的click事件可以叠加后面定义的事件不会覆盖前面定义的事件而是两个事件
都能执行，原生js事件会覆盖。
2016/11/7
// spanFather.children("span").unbind("click"); //用于取消重复在span上添加点击事件。
// spanFather.children("span").unbind("dblclick"); //用于取消重复在span上添加点击事件。
// spanFather.children("span").bind("click",changeBgcolor);
// spanFather.children("span").bind("dblclick",remove);

 <script src="../js/jquery-1.12.4.js"></script>
 <script src="/js/jquery-1.12.4.js"></script>//加不加前面的省略号很重要血的教训！！！！！！！
2016/11/8
element.tagName  返回元素的标签名(大写)
select标签的val()就是option标签的value

dom对象元素是超级全局变量

对于元素选择尽可能的准确选择

init 
在我的上一篇随笔里面分析了jQuery的构造函数，jQuery对象中有一个原型方法init才是是真正的构造函数，通过init的
原型对象跟jQuery的原型对象保持引用关系使得init的实例可以正常调用jQuery的原型方法，就好像是jQuery的实例一样。
下面就来看看init这个幕后的构造函数是怎么写的：
http://www.jb51.net/article/65981.htm

var p=$(a).parents("p"),span=$("<span></span>"),text=p.children("label").children("span").text();
//p.children("label")调用init对象 也就是jq对象
select的下拉框无法控制高度 只能自己模拟
option的click事件，在ff里可以 ，在chrome不行

2016/11/9
$("input").val("2012/11/22");无法设置中间有type为file类的值，导致后面的无法取值
2016/11/10
js创造的元素之间没有空格，html之间有空格所以宽度不一样 大坑啊！！！！！！

2016/11/11
使用JQ的after()对未添加到html文档中的元素使用时被添加的元素无法显示 a ,b 都是创造元素a.after(b),文档中并没有b。
var divD=$("<div>1</div>");//外面已经循环了 所以不需要再在自己创造了 又是一个大坑啊

11/16
src 链接到的地址URl

frameborder 是否显示边框（0无边框 1有边框）

scrolling 是否有滚动条（yes有滚动条 no无滚动条）

allowtransparency 背景是否透明（yes透明 no不透明）
http://www.cnblogs.com/kingboy2008/archive/2011/05/10/2055545.html

11/21
字符串有length 数值没有length
相对路径 ../../父级的父级
number()不是全部能转换成数字的话就输出NaN
enter的which值为13
click事件在JQ中会重复添加
键盘点击事件也会

11/22
jq中使用top 调用他的下级元素 $(top.document.body)最重要的还是js基础 非常重要
各种居中

1.最简单的flex布局,外层容器加上如下样式即可

display: flex;
justify-content: center;
align-items: center;

2.利用table-cell

外层容器
display:table-cell;
text-align:center;
vertical-align:middle;
内部元素
vertical-align:middle;
display:inline-block;

3.使用CSS3 transform
外层容器
display:relative
内部元素
transform: translate(-50%,-50%);
position: absolute;
top: 50%;
left: 50%;

2016/11/25
html元素设置100%对于使用iframe来说太重要了
一般的都不会设置为高度100% 坑填了一个
一切设计都是围绕数据进行的 数据跟逻辑还有视图一定要分开 方便进行后期修改 MVC就是这个道理

2016/11/28
良好的命名规则非常重要 非常提升效率
2016/11/29

phpstorm快捷键

ctrl+shift+n查找文件

ctrl+shift+f 在一个目录里查找一段代码(ctrl+f的升级版)

ctr+shift+r 在一个目录里查找一段代码并替换(ctrl+r的升级版)


CTRL+ALT ←/→  返回上次编辑的位置
ALT+ ←/→  切换代码视图，标签切换
ALT+ ↑/↓  在方法间快速移动定位


ctrl+j插入活动代码提示
ctrl+alt+t当前位置插入环绕代码
alt+insert生成代码菜单
ctrl+q查看代码注释
ctrl+d复制当前行
ctrl+y删除当前行
shift+F6重命名
ctrl+shift+u字母大小写转换
ctrl+f查找
ctrl+r替换
F4查看源码

ctrl+shift+i查看变量或方法定义源
ctrl+g跳转行
ctrl+alt+F12跳转至当前文件在磁盘上的位置
alt+down查看下一个方法
alt+up查看上一个方法
ctrl+alt+l重新格式化代码
ctrl+shift+downstatement向下移动
ctrl+shift+upstatement向上移动
alt+shift+downline向下移动
alt+shift+upline向上移动
ctrl+/行注释
ctrl+shift+/块注释
ctrl+shift+n打开工程中的文件
ctrl+b跳到变量申明处
ctrl+[]匹配 {}[]
ctrl+shift+]/[选中块代码
ctrl+x剪切行
ctrl+shift+v复制多个文本
alt+left/right标签切换
ctrl+p显示默认参数
ctrl+F12在当前类文件里快速查找方法
 
2016/12/1
iframe框架实验

试验成功 看test下的文档

2016/12/2

2016/12/5
看Jquery手册上说1.6以下版本在IE6使用JQuery的removeAttr方法删除disabled是无效的。解决的方法就是使用$("XX").prop("disabled",false);
attr和prop区别还是很大的
如果你的Jquery库的版本是1.6以下的，使用attr方法

如果你的Jquery库的版本是1.6（含1.6）以上的，使用prop方法
对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。
对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。

2016/12/7
好好研究一下laydate日期插件 以后就专门用这款插件了 


2016/12/8
<META HTTP-EQUIV="Pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache"> 
<META HTTP-EQUIV="Expires" CONTENT="0"> 
清除页面缓存的方法
在页面中的顺序很重要

2016/12/10
首先执行try，如果有异常执行catch，无论如何都会执行finally 

一个函数中肯定会执行finally中的部分。 

关于一个函数的执行过程是，当有return以后，函数就会把这个数据存储在某个位置，然后告诉主函数，我不执行了，接下来你执行吧，所以函数就会推出。 
但是当一个函数中出现finally以后，finally永远都要执行，所以，就算try或者catch中已经执行了return了，但是这时函数不会退出，不会告诉主函数去执行，
而是等待finally执行完了才回去告诉主函数去执行，这时候如果finally中出现了return的话，这次return的值就会覆盖掉try或者catch中的值，然后才会告诉
主函数：我不执行了，你去执行吧。所以主函数会得到finally中的返回值。也就是说子函数的返回值永远是finally中的返回值（只要被调用的函数中有值）

2016/12/12
(1)     先说jquery, 使用 jQuery 库的话，只需要同时绑定 oninput 和 onpropertychange 两个事件就可以了，
示例代码：
从上面表格可以看出，oninput 事件在 IE9 以下版本不支持，需要使用 IE 特有的 onpropertychange
事件替代，这个事件在用户界面改变或者使用脚本直接修改内容两种情况下都会触发，有以下几种情况：

修改了 input:checkbox 或者 input:radio 元素的选择中状态， checked 属性发生变化。
修改了 input:text 或者 textarea 元素的值，value 属性发生变化。
修改了 select 元素的选中项，selectedIndex 属性发生变化。


用settimeout处理先失去焦点再点击的事件
养成习惯进行清除定时器

2016/12/15
命令提示符

cd 重新定位文件夹位置  
示例 先进入D盘 输入 D: 然后定位下面的文件 cd web\page(要先定位进入D盘之后在进行定位操作，
要不然还是停留在原盘的位置，不过下次输入定位盘符就会进入上次在该盘的定位位置)
cd：进入或退出目录
格式：cd [[/d][x:][path][..]]
参数解释：
    ..      进入上一级目录
    /d     快速改变当前目录
    /？    在命令符显示帮助信息
    \        回到根目录
ren：对某个目录进行重命名
    格式：ren [x:][path]filename1 filename2
    参数解释：
    [x:][path]filename1         指定要重命名的文件夹或文件的位置和名称
    Filename2                      对文件重命名时指定的新文件名

dir 查看本文件夹下面的子文件夹

gulp安装相关操作指南

首先确保你已经正确安装了nodejs环境。然后以全局方式安装gulp：

cnpm install -g gulp
全局安装gulp后，还需要在每个要使用gulp的项目中都单独安装一次。把目录切换到你的项目文件夹中，然后在命令行中执行：

cnpm install gulp
如果想在安装的时候把gulp写进项目package.json文件的依赖中，则可以加上--save-dev：

cnpm install --save-dev gulp
这样就完成了gulp的安装。至于为什么在全局安装gulp后，还需要在项目中本地安装一次，有兴趣的可以看
下stackoverflow上有人做出的回答：why-do-we-need-to-install-gulp-globally-and-locally、what-is-the-point-of-double-install-in-gulp。
大体就是为了版本的灵活性，但如果没理解那也不必太去纠结这个问题，只需要知道通常我们是要这样做就行了。

http://www.cnblogs.com/2050/p/4198792.html(这个网址的教程不错)

* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾
** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。
? 匹配文件路径中的一个字符(不会匹配路径分隔符)
[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法
!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的
?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?
+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+
*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*
@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)
下面以一系列例子来加深理解

* 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js
*.* 能匹配 a.js,style.css,a.b,x.y
*/*/*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js
** 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件
**/*.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.js
a/**/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z
a/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录
?.js 能匹配 a.js,b.js,c.js
a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符
[xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符
[^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js
当有多种匹配模式时可以使用数组
当有多种匹配模式时可以使用数组

//使用数组的方式来匹配多种文件
gulp.src(['js/*.js','css/*.css','*.html'])
使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，
它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式


自动加载插件
npm install --save-dev gulp-load-plugins

重命名
npm install --save-dev gulp-rename

js文件压缩
npm install --save-dev gulp-uglify

css文件压缩
npm install --save-dev gulp-minify-css

 js代码检查
npm install --save-dev gulp-jshint

文件合并
npm install --save-dev gulp-concat

less和sass的编译
npm install --save-dev gulp-less
npm install --save-dev gulp-sass

图片压缩
npm install --save-dev gulp-imagemin

对文件名加MD5后缀
gulp-rev

路径替换
gulp-rev-collector

npm init
//- 生成一个 package.json，里面是一些常规的配置信息

npm install gulp gulp-concat gulp-minify-css gulp-rev gulp-rev-collector --save-dev
//- 安装插件到项目目录内
